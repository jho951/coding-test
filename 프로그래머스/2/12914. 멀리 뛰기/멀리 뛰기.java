class Solution {
    // 나머지 연산에 사용할 상수 (Modulo: 1234567)
    private final int MOD = 1234567;

    public long solution(int n) {
        // 문제의 특성상 F(n+1)을 구해야 하므로, DP 배열 크기를 n+2로 설정합니다.
        // n=4 일 때, F(5)=5를 계산해야 하므로, 배열은 F(0)부터 F(5)까지 필요합니다.
        // F(0)부터 F(n+1)까지 저장하기 위해 크기를 n + 2로 설정
        long[] fib = new long[n + 2];

        // n은 1 이상이므로 n=0, n=1 기저 사례는 사실상 필요 없지만,
        // 배열 접근의 안정성과 F(n+1) 계산을 위해 F(0)과 F(1)을 설정합니다.
        fib[0] = 1; // F(1)에 해당 (멀리뛰기 방법 수 W(0)을 1로 가정)
        fib[1] = 1; // W(1) = 1 (1칸)

        if (n <= 1) {
            // n=1일 때 W(1)=1 반환
            return 1;
        }

        // DP 반복문을 통해 F(2)부터 F(n+1)까지 계산
        // 배열 인덱스 i는 W(i)를 의미
        for (int i = 2; i <= n; i++) {
            // W(i) = (W(i-1) + W(i-2)) % MOD 공식을 적용
            // 여기서 W(i)는 F(i+1)의 값에 해당합니다.
            fib[i] = (fib[i - 1] + fib[i - 2]) % MOD;
        }

        // 최종적으로 n번째 칸에 도달하는 방법의 수 W(n)을 반환 (이는 배열 fib[n]에 저장되어 있습니다)
        // n=4일 때, fib[4] = 5를 반환합니다.
        return fib[n];
    }
}
