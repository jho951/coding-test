def solution(n):
    # 나누는 값 (Modulus)을 상수로 정의
    MOD = 1234567
    
    # n이 2 이상이므로, F(0)과 F(1)을 초기화합니다.
    # 배열을 사용하지 않고 변수 3개만으로도 가능하지만,
    # 배열을 사용하는 방식이 이해하기 쉽습니다.
    f = [0, 1]
    
    # n번째 피보나치 수를 구할 때까지 반복합니다. (F(2)부터 F(n)까지)
    # n이 2일 때 for문은 1번, n이 3일 때 2번... 총 n-1번 반복
    for i in range(2, n + 1):
        # 새로운 피보나치 수를 계산하고, 즉시 MOD로 나눈 나머지를 저장
        # F(i) = (F(i-1) + F(i-2)) % MOD
        next_fib = (f[i - 1] + f[i - 2]) % MOD
        f.append(next_fib)
        
    # F(n)의 값을 반환합니다. 
    # 리스트 f에는 F(0)부터 F(n)까지 총 n+1개의 원소가 들어있으며,
    # F(n)은 인덱스 n에 저장되어 있습니다.
    return f[n]