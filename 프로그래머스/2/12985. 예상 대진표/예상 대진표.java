class Solution {
    /**
     * N명의 참가자 중 A번 참가자와 B번 참가자가 몇 번째 라운드에서 만나는지 계산합니다.
     * 단, A와 B는 서로 붙기 전까지 항상 이긴다고 가정합니다.
     * * @param N 전체 참가자 수 (사용하지 않음, 토너먼트 진행을 위해 필요하지만, A와 B의 번호 갱신만으로 충분)
     * @param A 참가자 A의 초기 번호
     * @param B 참가자 B의 초기 번호
     * @return A와 B가 만나는 라운드 번호
     */
    public int solution(int N, int A, int B) {
        int round = 0;
        
        // A와 B가 만날 때까지 반복합니다.
        // A와 B가 만나는 조건은 다음 라운드에서 같은 번호를 부여받는 경우입니다.
        // 즉, ceil(A/2) == ceil(B/2) 인 경우 현재 라운드에서 맞붙습니다.
        while (A != B) {
            round++;
            
            // 만나는 조건 확인: A의 다음 라운드 번호와 B의 다음 라운드 번호가 같은지 확인
            // A와 B가 서로 붙게 되려면 다음 라운드에서 같은 번호가 되어야 합니다.
            // 예를 들어 (1, 2)는 다음 라운드 1, (3, 4)는 다음 라운드 2가 되므로, 
            // 현재 라운드에서 (1, 2)나 (3, 4)처럼 맞붙는다면 A와 B는 이미 다음 라운드에서 같아집니다.
            // 따라서, 다음 라운드 번호가 같아지기 직전의 라운드가 만나는 라운드입니다.
            if ((A + 1) / 2 == (B + 1) / 2) {
                return round;
            }
            
            // 다음 라운드 번호로 갱신: ceil(k/2)를 정수 연산으로 (k+1)/2로 계산
            A = (A + 1) / 2;
            B = (B + 1) / 2;
        }
        
        // 이 코드는 A와 B가 이미 같은 경우에 도달하지만,
        // 문제 조건상 A != B로 시작하므로, 위 while문 안에서 항상 return 될 것입니다.
        return round; 
    }
}